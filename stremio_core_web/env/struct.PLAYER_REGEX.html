<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `PLAYER_REGEX` struct in crate `stremio_core_web`."><title>PLAYER_REGEX in stremio_core_web::env - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-dd39b87e5fcfba68.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="stremio_core_web" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0-nightly (35b658fb1 2024-07-08)" data-channel="nightly" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-20a3ad099b048cf2.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../stremio_core_web/index.html">stremio_core_web</a><span class="version">0.47.7</span></h2></div><h2 class="location"><a href="#">PLAYER_REGEX</a></h2><div class="sidebar-elems"><section><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.__private_field">__private_field</a></li></ul><h3><a href="#deref-methods-Regex">Methods from Deref&lt;Target=Regex&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.as_str">as_str</a></li><li><a href="#method.capture_locations">capture_locations</a></li><li><a href="#method.capture_names">capture_names</a></li><li><a href="#method.captures">captures</a></li><li><a href="#method.captures_at">captures_at</a></li><li><a href="#method.captures_iter">captures_iter</a></li><li><a href="#method.captures_len">captures_len</a></li><li><a href="#method.captures_read">captures_read</a></li><li><a href="#method.captures_read_at">captures_read_at</a></li><li><a href="#method.find">find</a></li><li><a href="#method.find_at">find_at</a></li><li><a href="#method.find_iter">find_iter</a></li><li><a href="#method.is_match">is_match</a></li><li><a href="#method.is_match_at">is_match_at</a></li><li><a href="#method.replace">replace</a></li><li><a href="#method.replace_all">replace_all</a></li><li><a href="#method.replacen">replacen</a></li><li><a href="#method.shortest_match">shortest_match</a></li><li><a href="#method.shortest_match_at">shortest_match_at</a></li><li><a href="#method.split">split</a></li><li><a href="#method.splitn">splitn</a></li><li><a href="#method.static_captures_len">static_captures_len</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-__Deref-for-PLAYER_REGEX">Deref</a></li><li><a href="#impl-LazyStatic-for-PLAYER_REGEX">LazyStatic</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-PLAYER_REGEX">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-PLAYER_REGEX">RefUnwindSafe</a></li><li><a href="#impl-Send-for-PLAYER_REGEX">Send</a></li><li><a href="#impl-Sync-for-PLAYER_REGEX">Sync</a></li><li><a href="#impl-Unpin-for-PLAYER_REGEX">Unpin</a></li><li><a href="#impl-UnwindSafe-for-PLAYER_REGEX">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-ConditionalSend-for-T">ConditionalSend</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Instrument-for-T">Instrument</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-Same-for-T">Same</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li><li><a href="#impl-WithSubscriber-for-T">WithSubscriber</a></li></ul></section><h2><a href="index.html">In stremio_core_web::env</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="../index.html">stremio_core_web</a>::<wbr><a href="index.html">env</a>::<wbr><a class="struct" href="#">PLAYER_REGEX</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/stremio_core_web/env.rs.html#53-60">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>struct PLAYER_REGEX {
    __private_field: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>,
}</code></pre><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.__private_field" class="structfield section-header"><a href="#structfield.__private_field" class="anchor field">§</a><code>__private_field: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a></code></span><h2 id="deref-methods-Regex" class="section-header"><span>Methods from <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a>&lt;Target = Regex&gt;</span><a href="#deref-methods-Regex" class="anchor">§</a></h2><div id="deref-methods-Regex-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.is_match" class="method"><h4 class="code-header">pub fn <a href="#method.is_match" class="fn">is_match</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns true if and only if there is a match for the regex in the
string given.</p>
<p>It is recommended to use this method if all you need to do is test
a match, since the underlying matching engine may be able to do less
work.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<p>Test if some text contains at least one word with exactly 13
Unicode word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"I categorically deny having triskaidekaphobia."</span>;
<span class="macro">assert!</span>(Regex::new(<span class="string">r"\b\w{13}\b"</span>).unwrap().is_match(text));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;'t&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the start and end byte range of the leftmost-first match in
<code>text</code>. If no match exists, then <code>None</code> is returned.</p>
<p>Note that this should only be used if you want to discover the position
of the match. Testing the existence of a match is faster if you use
<code>is_match</code>.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>Find the start and end location of the first word with exactly 13
Unicode word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"I categorically deny having triskaidekaphobia."</span>;
<span class="kw">let </span>mat = Regex::new(<span class="string">r"\b\w{13}\b"</span>).unwrap().find(text).unwrap();
<span class="macro">assert_eq!</span>(mat.start(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(mat.end(), <span class="number">15</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_iter" class="method"><h4 class="code-header">pub fn <a href="#method.find_iter" class="fn">find_iter</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; Matches&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator for each successive non-overlapping match in
<code>text</code>, returning the start and end byte indices with respect to
<code>text</code>.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>Find the start and end location of every word with exactly 13 Unicode
word characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"Retroactively relinquishing remunerations is reprehensible."</span>;
<span class="kw">for </span>mat <span class="kw">in </span>Regex::new(<span class="string">r"\b\w{13}\b"</span>).unwrap().find_iter(text) {
    <span class="macro">println!</span>(<span class="string">"{:?}"</span>, mat);
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures" class="method"><h4 class="code-header">pub fn <a href="#method.captures" class="fn">captures</a>&lt;'t&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Captures&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the capture groups corresponding to the leftmost-first
match in <code>text</code>. Capture group <code>0</code> always corresponds to the entire
match. If no match is found, then <code>None</code> is returned.</p>
<p>You should only use <code>captures</code> if you need access to the location of
capturing group matches. Otherwise, <code>find</code> is faster for discovering
the location of the overall match.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<p>Say you have some text with movie names and their release years,
like “‘Citizen Kane’ (1941)”. It’d be nice if we could search for text
looking like that, while also extracting the movie name and its release
year separately.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"'([^']+)'\s+\((\d{4})\)"</span>).unwrap();
<span class="kw">let </span>text = <span class="string">"Not my favorite movie: 'Citizen Kane' (1941)."</span>;
<span class="kw">let </span>caps = re.captures(text).unwrap();
<span class="macro">assert_eq!</span>(caps.get(<span class="number">1</span>).unwrap().as_str(), <span class="string">"Citizen Kane"</span>);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">2</span>).unwrap().as_str(), <span class="string">"1941"</span>);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">0</span>).unwrap().as_str(), <span class="string">"'Citizen Kane' (1941)"</span>);
<span class="comment">// You can also access the groups by index using the Index notation.
// Note that this will panic on an invalid index.
</span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">1</span>], <span class="string">"Citizen Kane"</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">2</span>], <span class="string">"1941"</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">0</span>], <span class="string">"'Citizen Kane' (1941)"</span>);</code></pre></div>
<p>Note that the full match is at capture group <code>0</code>. Each subsequent
capture group is indexed by the order of its opening <code>(</code>.</p>
<p>We can make this example a bit clearer by using <em>named</em> capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"'(?P&lt;title&gt;[^']+)'\s+\((?P&lt;year&gt;\d{4})\)"</span>)
               .unwrap();
<span class="kw">let </span>text = <span class="string">"Not my favorite movie: 'Citizen Kane' (1941)."</span>;
<span class="kw">let </span>caps = re.captures(text).unwrap();
<span class="macro">assert_eq!</span>(caps.name(<span class="string">"title"</span>).unwrap().as_str(), <span class="string">"Citizen Kane"</span>);
<span class="macro">assert_eq!</span>(caps.name(<span class="string">"year"</span>).unwrap().as_str(), <span class="string">"1941"</span>);
<span class="macro">assert_eq!</span>(caps.get(<span class="number">0</span>).unwrap().as_str(), <span class="string">"'Citizen Kane' (1941)"</span>);
<span class="comment">// You can also access the groups by name using the Index notation.
// Note that this will panic on an invalid group name.
</span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="string">"title"</span>], <span class="string">"Citizen Kane"</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="string">"year"</span>], <span class="string">"1941"</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>caps[<span class="number">0</span>], <span class="string">"'Citizen Kane' (1941)"</span>);
</code></pre></div>
<p>Here we name the capture groups, which we can access with the <code>name</code>
method or the <code>Index</code> notation with a <code>&amp;str</code>. Note that the named
capture groups are still accessible with <code>get</code> or the <code>Index</code> notation
with a <code>usize</code>.</p>
<p>The <code>0</code>th capture group is always unnamed, so it must always be
accessed with <code>get(0)</code> or <code>[0]</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures_iter" class="method"><h4 class="code-header">pub fn <a href="#method.captures_iter" class="fn">captures_iter</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; CaptureMatches&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over all the non-overlapping capture groups matched
in <code>text</code>. This is operationally the same as <code>find_iter</code>, except it
yields information about capturing group matches.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>We can use this to find all movie titles and their release years in
some text, where the movie is formatted like “‘Title’ (xxxx)”:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"'(?P&lt;title&gt;[^']+)'\s+\((?P&lt;year&gt;\d{4})\)"</span>)
               .unwrap();
<span class="kw">let </span>text = <span class="string">"'Citizen Kane' (1941), 'The Wizard of Oz' (1939), 'M' (1931)."</span>;
<span class="kw">for </span>caps <span class="kw">in </span>re.captures_iter(text) {
    <span class="macro">println!</span>(<span class="string">"Movie: {:?}, Released: {:?}"</span>,
             <span class="kw-2">&amp;</span>caps[<span class="string">"title"</span>], <span class="kw-2">&amp;</span>caps[<span class="string">"year"</span>]);
}
<span class="comment">// Output:
// Movie: Citizen Kane, Released: 1941
// Movie: The Wizard of Oz, Released: 1939
// Movie: M, Released: 1931</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; Split&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of substrings of <code>text</code> delimited by a match of the
regular expression. Namely, each element of the iterator corresponds to
text that <em>isn’t</em> matched by the regular expression.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<p>To split a string delimited by arbitrary amounts of spaces or tabs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"[ \t]+"</span>).unwrap();
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = re.split(<span class="string">"a b \t  c\td    e"</span>).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;'r, 't&gt;(&amp;'r self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; SplitN&lt;'r, 't&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator of at most <code>limit</code> substrings of <code>text</code> delimited
by a match of the regular expression. (A <code>limit</code> of <code>0</code> will return no
substrings.) Namely, each element of the iterator corresponds to text
that <em>isn’t</em> matched by the regular expression. The remainder of the
string that is not split will be the last element in the iterator.</p>
<p>This method will <em>not</em> copy the text given.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<p>Get the first two words in some text:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"\W+"</span>).unwrap();
<span class="kw">let </span>fields: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = re.splitn(<span class="string">"Hey! How are you?"</span>, <span class="number">3</span>).collect();
<span class="macro">assert_eq!</span>(fields, <span class="macro">vec!</span>(<span class="string">"Hey"</span>, <span class="string">"How"</span>, <span class="string">"are you?"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>&lt;'t, R&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<div class="where">where
    R: Replacer,</div></h4></section></summary><div class="docblock"><p>Replaces the leftmost-first match with the replacement provided.
The replacement can be a regular string (where <code>$N</code> and <code>$name</code> are
expanded to match capture groups) or a function that takes the matches’
<code>Captures</code> and returns the replaced string.</p>
<p>If no match is found, then a copy of the string is returned unchanged.</p>
<h5 id="replacement-string-syntax"><a class="doc-anchor" href="#replacement-string-syntax">§</a>Replacement string syntax</h5>
<p>All instances of <code>$name</code> in the replacement text is replaced with the
corresponding capture group <code>name</code>.</p>
<p><code>name</code> may be an integer corresponding to the index of the
capture group (counted by order of opening parenthesis where <code>0</code> is the
entire match) or it can be a name (consisting of letters, digits or
underscores) corresponding to a named capture group.</p>
<p>If <code>name</code> isn’t a valid capture group (whether the name doesn’t exist
or isn’t a valid index), then it is replaced with the empty string.</p>
<p>The longest possible name is used. e.g., <code>$1a</code> looks up the capture
group named <code>1a</code> and not the capture group at index <code>1</code>. To exert more
precise control over the name, use braces, e.g., <code>${1}a</code>.</p>
<p>To write a literal <code>$</code> use <code>$$</code>.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<p>Note that this function is polymorphic with respect to the replacement.
In typical usage, this can just be a normal string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">"[^01]+"</span>).unwrap();
<span class="macro">assert_eq!</span>(re.replace(<span class="string">"1078910"</span>, <span class="string">""</span>), <span class="string">"1010"</span>);</code></pre></div>
<p>But anything satisfying the <code>Replacer</code> trait will work. For example,
a closure of type <code>|&amp;Captures| -&gt; String</code> provides direct access to the
captures corresponding to a match. This allows one to access
capturing group matches easily:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"([^,\s]+),\s+(\S+)"</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">"Springsteen, Bruce"</span>, |caps: <span class="kw-2">&amp;</span>Captures| {
    <span class="macro">format!</span>(<span class="string">"{} {}"</span>, <span class="kw-2">&amp;</span>caps[<span class="number">2</span>], <span class="kw-2">&amp;</span>caps[<span class="number">1</span>])
});
<span class="macro">assert_eq!</span>(result, <span class="string">"Bruce Springsteen"</span>);</code></pre></div>
<p>But this is a bit cumbersome to use all the time. Instead, a simple
syntax is supported that expands <code>$name</code> into the corresponding capture
group. Here’s the last example, but using this expansion technique
with named capture groups:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"(?P&lt;last&gt;[^,\s]+),\s+(?P&lt;first&gt;\S+)"</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">"Springsteen, Bruce"</span>, <span class="string">"$first $last"</span>);
<span class="macro">assert_eq!</span>(result, <span class="string">"Bruce Springsteen"</span>);</code></pre></div>
<p>Note that using <code>$2</code> instead of <code>$first</code> or <code>$1</code> instead of <code>$last</code>
would produce the same result. To write a literal <code>$</code> use <code>$$</code>.</p>
<p>Sometimes the replacement string requires use of curly braces to
delineate a capture group replacement and surrounding literal text.
For example, if we wanted to join two words together with an
underscore:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>re = Regex::new(<span class="string">r"(?P&lt;first&gt;\w+)\s+(?P&lt;second&gt;\w+)"</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">"deep fried"</span>, <span class="string">"${first}_$second"</span>);
<span class="macro">assert_eq!</span>(result, <span class="string">"deep_fried"</span>);</code></pre></div>
<p>Without the curly braces, the capture group name <code>first_</code> would be
used, and since it doesn’t exist, it would be replaced with the empty
string.</p>
<p>Finally, sometimes you just want to replace a literal string with no
regard for capturing group expansion. This can be done by wrapping a
byte string with <code>NoExpand</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::NoExpand;

<span class="kw">let </span>re = Regex::new(<span class="string">r"(?P&lt;last&gt;[^,\s]+),\s+(\S+)"</span>).unwrap();
<span class="kw">let </span>result = re.replace(<span class="string">"Springsteen, Bruce"</span>, NoExpand(<span class="string">"$2 $last"</span>));
<span class="macro">assert_eq!</span>(result, <span class="string">"$2 $last"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace_all" class="method"><h4 class="code-header">pub fn <a href="#method.replace_all" class="fn">replace_all</a>&lt;'t, R&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, rep: R) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<div class="where">where
    R: Replacer,</div></h4></section></summary><div class="docblock"><p>Replaces all non-overlapping matches in <code>text</code> with the replacement
provided. This is the same as calling <code>replacen</code> with <code>limit</code> set to
<code>0</code>.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen" class="method"><h4 class="code-header">pub fn <a href="#method.replacen" class="fn">replacen</a>&lt;'t, R&gt;(
    &amp;self,
    text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
    limit: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    rep: R,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/alloc/borrow/enum.Cow.html" title="enum alloc::borrow::Cow">Cow</a>&lt;'t, <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;<div class="where">where
    R: Replacer,</div></h4></section></summary><div class="docblock"><p>Replaces at most <code>limit</code> non-overlapping matches in <code>text</code> with the
replacement provided. If <code>limit</code> is 0, then all non-overlapping matches
are replaced.</p>
<p>See the documentation for <code>replace</code> for details on how to access
capturing group matches in the replacement string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shortest_match" class="method"><h4 class="code-header">pub fn <a href="#method.shortest_match" class="fn">shortest_match</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the end location of a match in the text given.</p>
<p>This method may have the same performance characteristics as
<code>is_match</code>, except it provides an end location for a match. In
particular, the location returned <em>may be shorter</em> than the proper end
of the leftmost-first match that you would find via <code>Regex::find</code>.</p>
<p>Note that it is not guaranteed that this routine finds the shortest or
“earliest” possible match. Instead, the main idea of this API is that
it returns the offset at the point at which the internal regex engine
has determined that a match has occurred. This may vary depending on
which internal regex engine is used, and thus, the offset itself may
change.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<p>Typically, <code>a+</code> would match the entire first sequence of <code>a</code> in some
text, but <code>shortest_match</code> can give up as soon as it sees the first
<code>a</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"aaaaa"</span>;
<span class="kw">let </span>pos = Regex::new(<span class="string">r"a+"</span>).unwrap().shortest_match(text);
<span class="macro">assert_eq!</span>(pos, <span class="prelude-val">Some</span>(<span class="number">1</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.shortest_match_at" class="method"><h4 class="code-header">pub fn <a href="#method.shortest_match_at" class="fn">shortest_match_at</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the same as <code>shortest_match</code>, but starts the search at the
given offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only match
when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_match_at" class="method"><h4 class="code-header">pub fn <a href="#method.is_match_at" class="fn">is_match_at</a>(&amp;self, text: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns the same as is_match, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find_at" class="method"><h4 class="code-header">pub fn <a href="#method.find_at" class="fn">find_at</a>&lt;'t&gt;(&amp;self, text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as find, but starts the search at the given
offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures_at" class="method"><h4 class="code-header">pub fn <a href="#method.captures_at" class="fn">captures_at</a>&lt;'t&gt;(
    &amp;self,
    text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
    start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Captures&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as [<code>Regex::captures</code>], but starts the search at the
given offset.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures_read" class="method"><h4 class="code-header">pub fn <a href="#method.captures_read" class="fn">captures_read</a>&lt;'t&gt;(
    &amp;self,
    locs: &amp;mut CaptureLocations,
    text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>This is like <code>captures</code>, but uses
<a href="struct.CaptureLocations.html"><code>CaptureLocations</code></a>
instead of
<a href="struct.Captures.html"><code>Captures</code></a> in order to amortize allocations.</p>
<p>To create a <code>CaptureLocations</code> value, use the
<code>Regex::capture_locations</code> method.</p>
<p>This returns the overall match if this was successful, which is always
equivalence to the <code>0</code>th capture group.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures_read_at" class="method"><h4 class="code-header">pub fn <a href="#method.captures_read_at" class="fn">captures_read_at</a>&lt;'t&gt;(
    &amp;self,
    locs: &amp;mut CaptureLocations,
    text: &amp;'t <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>,
    start: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Match&lt;'t&gt;&gt;</h4></section></summary><div class="docblock"><p>Returns the same as captures, but starts the search at the given
offset and populates the capture locations given.</p>
<p>The significance of the starting point is that it takes the surrounding
context into consideration. For example, the <code>\A</code> anchor can only
match when <code>start == 0</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_str" class="method"><h4 class="code-header">pub fn <a href="#method.as_str" class="fn">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class="docblock"><p>Returns the original string of this regex.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capture_names" class="method"><h4 class="code-header">pub fn <a href="#method.capture_names" class="fn">capture_names</a>(&amp;self) -&gt; CaptureNames&lt;'_&gt;</h4></section></summary><div class="docblock"><p>Returns an iterator over the capture names.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.captures_len" class="method"><h4 class="code-header">pub fn <a href="#method.captures_len" class="fn">captures_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the number of captures.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.static_captures_len" class="method"><h4 class="code-header">pub fn <a href="#method.static_captures_len" class="fn">static_captures_len</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the total number of capturing groups that appear in every
possible match.</p>
<p>If the number of capture groups can vary depending on the match, then
this returns <code>None</code>. That is, a value is only returned when the number
of matching groups is invariant or “static.”</p>
<p>Note that like [<code>Regex::captures_len</code>], this <strong>does</strong> include the
implicit capturing group corresponding to the entire match. Therefore,
when a non-None value is returned, it is guaranteed to be at least <code>1</code>.
Stated differently, a return value of <code>Some(0)</code> is impossible.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<p>This shows a few cases where a static number of capture groups is
available and a few cases where it is not.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>regex::Regex;

<span class="kw">let </span>len = |pattern| {
    Regex::new(pattern).map(|re| re.static_captures_len())
};

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), len(<span class="string">"a"</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), len(<span class="string">"(a)"</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), len(<span class="string">"(a)|(b)"</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), len(<span class="string">"(a)(b)|(c)(d)"</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">"(a)|b"</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">"a|(b)"</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, len(<span class="string">"(b)*"</span>)<span class="question-mark">?</span>);
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), len(<span class="string">"(b)+"</span>)<span class="question-mark">?</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.capture_locations" class="method"><h4 class="code-header">pub fn <a href="#method.capture_locations" class="fn">capture_locations</a>(&amp;self) -&gt; CaptureLocations</h4></section></summary><div class="docblock"><p>Returns an empty set of capture locations that can be reused in
multiple calls to <code>captures_read</code> or <code>captures_read_at</code>.</p>
</div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-__Deref-for-PLAYER_REGEX" class="impl"><a class="src rightside" href="../../src/stremio_core_web/env.rs.html#53-60">source</a><a href="#impl-__Deref-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html" title="trait core::ops::deref::Deref">Deref</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = Regex</h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a class="src rightside" href="../../src/stremio_core_web/env.rs.html#53-60">source</a><a href="#method.deref" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/ops/deref/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;Regex</h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><section id="impl-LazyStatic-for-PLAYER_REGEX" class="impl"><a class="src rightside" href="../../src/stremio_core_web/env.rs.html#53-60">source</a><a href="#impl-LazyStatic-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://docs.rs/lazy_static/1.4.0/lazy_static/trait.LazyStatic.html" title="trait lazy_static::LazyStatic">LazyStatic</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-PLAYER_REGEX" class="impl"><a href="#impl-Freeze-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section><section id="impl-RefUnwindSafe-for-PLAYER_REGEX" class="impl"><a href="#impl-RefUnwindSafe-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section><section id="impl-Send-for-PLAYER_REGEX" class="impl"><a href="#impl-Send-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section><section id="impl-Sync-for-PLAYER_REGEX" class="impl"><a href="#impl-Sync-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section><section id="impl-Unpin-for-PLAYER_REGEX" class="impl"><a href="#impl-Unpin-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section><section id="impl-UnwindSafe-for-PLAYER_REGEX" class="impl"><a href="#impl-UnwindSafe-for-PLAYER_REGEX" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.PLAYER_REGEX.html" title="struct stremio_core_web::env::PLAYER_REGEX">PLAYER_REGEX</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#765">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#768">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Instrument-for-T" class="impl"><a class="src rightside" href="https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#276">source</a><a href="#impl-Instrument-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html" title="trait tracing::instrument::Instrument">Instrument</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.instrument" class="method trait-impl"><a class="src rightside" href="https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#82">source</a><a href="#method.instrument" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.instrument" class="fn">instrument</a>(self, span: <a class="struct" href="https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html" title="struct tracing::span::Span">Span</a>) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.37/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the provided <a href="https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.instrument">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.in_current_span" class="method trait-impl"><a class="src rightside" href="https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#121">source</a><a href="#method.in_current_span" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.in_current_span" class="fn">in_current_span</a>(self) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.37/tracing/instrument/struct.Instrumented.html" title="struct tracing::instrument::Instrumented">Instrumented</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Instruments this type with the <a href="https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html#method.current" title="associated function tracing::span::Span::current">current</a> <a href="https://docs.rs/tracing/0.1.37/tracing/span/struct.Span.html" title="struct tracing::span::Span"><code>Span</code></a>, returning an
<code>Instrumented</code> wrapper. <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.Instrument.html#method.in_current_span">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#748-750">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#758">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Same-for-T" class="impl"><a class="src rightside" href="https://docs.rs/typenum/1.15.0/src/typenum/type_operators.rs.html#34">source</a><a href="#impl-Same-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/typenum/1.15.0/typenum/type_operators/trait.Same.html" title="trait typenum::type_operators::Same">Same</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="https://docs.rs/typenum/1.15.0/typenum/type_operators/trait.Same.html#associatedtype.Output" class="associatedtype">Output</a> = T</h4></section></summary><div class='docblock'>Should always be <code>Self</code></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805-807">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#790-792">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-WithSubscriber-for-T" class="impl"><a class="src rightside" href="https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#334">source</a><a href="#impl-WithSubscriber-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html" title="trait tracing::instrument::WithSubscriber">WithSubscriber</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.with_subscriber" class="method trait-impl"><a class="src rightside" href="https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#169-171">source</a><a href="#method.with_subscriber" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_subscriber" class="fn">with_subscriber</a>&lt;S&gt;(self, subscriber: S) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt;<div class="where">where
    S: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;Dispatch&gt;,</div></h4></section></summary><div class='docblock'>Attaches the provided <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
<a href="https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_subscriber">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.with_current_subscriber" class="method trait-impl"><a class="src rightside" href="https://docs.rs/tracing/0.1.37/src/tracing/instrument.rs.html#221">source</a><a href="#method.with_current_subscriber" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber" class="fn">with_current_subscriber</a>(self) -&gt; <a class="struct" href="https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch">WithDispatch</a>&lt;Self&gt;</h4></section></summary><div class='docblock'>Attaches the current <a href="https://docs.rs/tracing/0.1.37/tracing/dispatcher/index.html#setting-the-default-subscriber" title="mod tracing::dispatcher">default</a> <a href="super::Subscriber"><code>Subscriber</code></a> to this type, returning a
<a href="https://docs.rs/tracing/0.1.37/tracing/instrument/struct.WithDispatch.html" title="struct tracing::instrument::WithDispatch"><code>WithDispatch</code></a> wrapper. <a href="https://docs.rs/tracing/0.1.37/tracing/instrument/trait.WithSubscriber.html#method.with_current_subscriber">Read more</a></div></details></div></details><section id="impl-ConditionalSend-for-T" class="impl"><a class="src rightside" href="../../src/stremio_core/runtime/env.rs.html#101">source</a><a href="#impl-ConditionalSend-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../stremio_core/runtime/env/conditional_types/trait.ConditionalSend.html" title="trait stremio_core::runtime::env::conditional_types::ConditionalSend">ConditionalSend</a> for T</h3></section></div></section></div></main></body></html>